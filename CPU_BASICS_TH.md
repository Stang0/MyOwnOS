# พื้นฐานสถาปัตยกรรม x86 และภาษา Assembly

เอกสารนี้สรุปข้อมูลพื้นฐานที่จำเป็นในการพัฒนา Kernel เกี่ยวกับเครื่องมือและกลไกภายในของ CPU

---

## 1. x86 CPU Registers (ลิ้นชักเก็บข้อมูลใน CPU)

Registers คือหน่วยความจำความเร็วสูงที่อยู่ภายในตัว CPU เอง มักใช้เพื่อเก็บข้อมูลชั่วคราวขณะประมวลผล ในระบบ **64-bit (x86_64)** รีจิสเตอร์เหล่านี้จะมีขนาด 64 บิต

### General Purpose Registers (รีจิสเตอร์ใช้งานทั่วไป)
ใช้สำหรับการคำนวณและเก็บที่อยู่หน่วยความจำ:

| ชื่อ (64-bit) | หน้าที่หลัก |
| :--- | :--- |
| **RAX** | Accumulator: ใช้เก็บผลลัพธ์การคำนวณและค่าส่งกลับจากฟังก์ชัน |
| **RBX** | Base: ใช้เก็บที่อยู่ชั่วคราวในหน่วยความจำ |
| **RCX** | Counter: ใช้เป็นตัวนับในลูป (Loop Counter) |
| **RDX** | Data: ใช้ในการคำนวณคูณ/หาร และงาน I/O |
| **RSI** | Source Index: ชี้ตำแหน่งข้อมูลต้นทางสำหรับการก๊อปปี้ |
| **RDI** | Destination Index: ชี้ตำแหน่งข้อมูลปลายทางสำหรับการก๊อปปี้ |
| **RSP** | Stack Pointer: **(สำคัญ)** ชี้ไปที่ยอดบนสุดของ Stack ปัจจุบัน |
| **RBP** | Base Pointer: ชี้ไปยังฐานของฟังก์ชันปัจจุบันบน Stack |
| **R8 - R15** | ลิ้นชักเสริมสำหรับงานทั่วไปที่มีเฉพาะในโหมด 64-bit |

> **หมายเหตุ:** คุณสามารถเข้าถึงส่วนย่อยของรีจิสเตอร์ได้ เช่น **EAX** (32-bit ล่าง), **AX** (16-bit ล่าง), **AL** (8-bit ล่างสุด)

---

## 2. EFLAGS Register (แผงไฟสัญญาณเตือน)

EFLAGS คือรีจิสเตอร์พิเศษขนาด 32 บิตที่แต่ละบิตทำหน้าที่เป็น "ธง" (Flag) บอกสถานะหรือควบคุมการทำงานของ CPU

### ประเภทของธง (Flags)

#### ก. Status Flags (บอกผลลัพธ์การคำนวณ)
ใช้หลังจากคำสั่งประเภท `cmp`, `add`, `sub`, `test` เป็นต้น:
| บิตที่ | ชื่อ | หน้าที่ |
| :--- | :--- | :--- |
| **0** | **CF (Carry)** | สว่างถ้ามีการ "ทดเลข" หรือ "ยืมเลข" เกินหลักสูงสุด |
| **6** | **ZF (Zero)** | สว่างถ้าผลลัพธ์จากการคำนวณล่าสุดเป็น **0** |
| **7** | **SF (Sign)** | สว่างถ้าผลลัพธ์เป็นค่าติดลบ |
| **11** | **OF (Overflow)** | สว่างถ้าผลลัพธ์มีค่ามากเกินกว่าที่รีจิสเตอร์จะเก็บได้ |

#### ข. Control & System Flags (ควบคุมการทำงานระบบ)
| บิตที่ | ชื่อ | หน้าที่ |
| :--- | :--- | :--- |
| **9** | **IF (Interrupt)** | **สำคัญมาก:** ถ้าเป็น 0 CPU จะไม่รับเรื่องจากคดีภายนอก (cli/sti ใช้ควบคุมตัวนี้) |
| **10** | **DF (Direction)** | ควบคุมทิศทางการประมวลผลข้อมูลสายอักขระ (ซ้ายไปขวา หรือ ขวาไปซ้าย) |
| **21** | **ID (ID Flag)** | **ตัวที่เราใช้เช็ค CPUID:** ถ้าเราสลับค่าบิตนี้ได้ แปลว่า CPU รองรับคำสั่ง CPUID |

---

## 3. Segment Registers (รีจิสเตอร์ส่วนงาน)

รีจิสเตอร์กลุ่มนี้ไม่ได้มีไว้เก็บตัวเลขคำนวณเหมือน RAX แต่มีไว้เพื่อระบุ **"ขอบเขต" (Segment)** หรือสิทธิ์การเข้าถึงหน่วยความจำในแต่ละส่วน:

| ชื่อ | ชื่อเต็ม | หน้าที่ในปัจจุบัน |
| :--- | :--- | :--- |
| **CS** | Code Segment | ชี้ไปยังส่วนที่มีโค้ดโปรแกรมรันอยู่ (ใช้ระบุ Privilege Level) |
| **DS** | Data Segment | ชี้ไปยังส่วนที่เก็บข้อมูลทั่วไป (ใน 64-bit มักถูกตั้งเป็น 0) |
| **SS** | Stack Segment | ชี้ไปยังพื้นที่ Stack (พื้นที่ทำงานชั่วคราว) |
| **ES** | Extra Segment | รีจิสเตอร์เสริมสำหรับเก็บข้อมูล |
| **FS / GS** | Segment F / G | รีจิสเตอร์พิเศษที่ OS มักใช้เก็บข้อมูลเฉพาะของแต่ละ Thread |

> **ในโหมด 64-bit:** CPU จะมองข้ามการป้องกันของ DS, ES, SS เป็นส่วนใหญ่ (Flat Model) เราจึงมักล้างค่าพวกนี้ให้เป็น **0** ทันทีที่เข้าสู่ Long Mode เพื่อความปลอดภัยและเป็นระเบียบครับ

---

## 4. x86_64 4-Level Paging (การจัดการหน่วยความจำแบบลำดับชั้น)

### GDT (Global Descriptor Table)
คือตารางข้อมูลที่ OS ต้องสร้างขึ้นเพื่อบอก CPU ว่าแต่ละ Segment มีสิทธิ์อะไร และมีขนาดเท่าไหร่ ก่อนที่จะสลับเข้าสู่โหมด 64-bit

---

## 4. x86_64 4-Level Paging (การจัดการหน่วยความจำแบบลำดับชั้น)

ในโหมด 64-bit CPU บังคับให้ใช้ระบบ **Paging** เพื่อเปลี่ยนที่อยู่เสมือน (Virtual Address) ให้เป็นที่อยู่จริงในแรม (Physical Address) โดยแบ่งเป็น 4 ระดับ:

### ลำดับชั้นของตาราง (Hierarchy)
1.  **PML4 (Page Map Level 4):** รากฐานสูงสุด (Root) ชี้ไปยังตาราง PDP
2.  **PDP (Page Directory Pointer):** ชี้ไปยังตาราง Page Directory
3.  **PD (Page Directory):** ชี้ไปยังตาราง Page Table
4.  **PT (Page Table):** ชี้ไปยังตำแหน่งข้อมูลจริงในแรม (Physical Page Frame) ขนาด 4KB

### บิตควบคุมที่สำคัญ (Entry Flags)
ในแต่ละช่องของตาราง (Entry) จะมีบิตเพื่อบอกคุณสมบัติ เช่น:
*   **Bit 0 (Present):** 1 = หน้านี้มีอยู่จริงในแรม, 0 = จะเกิด Page Fault ถ้าเรียกใช้
*   **Bit 1 (Writable):** 1 = เขียนข้อมูลได้, 0 = อ่านได้อย่างเดียว
*   **Bit 2 (User/Supervisor):** 1 = แอปทั่วไปใช้ได้, 0 = เฉพาะ Kernel เท่านั้น

---

## 5. Assembly Instructions (คำสั่งพื้นฐาน)

ภาษา Assembly คือคำสั่งที่ส่งตรงถึง CPU โดยตรง

### การเคลื่อนย้ายข้อมูล (Data Movement)
*   `mov a, b`: คัดลอกค่าจาก `b` ไปใส่ใน `a`
*   `push a`: นำค่า `a` ไปวางไว้บนยอด Stack
*   `pop a`: ดึงค่าจากยอด Stack มาใส่ใน `a`

### การควบคุมทิศทาง (Control Flow)
*   `jump`, `jmp label`: กระโดดไปรันโค้ดที่ `label` ทันที
*   `call func`: เรียกฟังก์ชัน `func` (บันทึกทางกลับไว้บน Stack)
*   `ret`: จบฟังก์ชันและกลับไปจุดที่เรียกมา

### การตรวจสอบและเปรียบเทียบ
*   `cmp a, b`: เปรียบเทียบ `a` กับ `b`
*   `je` / `jne`: กระโดดถ้าผลลัพธ์ เท่ากัน / ไม่เท่ากัน
*   `test a, b`: ตรวจสอบสถานะบิต (มักใช้เช็คว่าค่าเป็น 0 หรือไม่)

### คำสั่งเฉพาะของระบบ (System Instructions)
*   `lgdt [ptr]`: โหลดตาราง GDT เข้าสู่ CPU
*   `cli` / `sti`: ปิด (Clear) / เปิด (Set) การรับข่าวสารจากภายนอก (Interrupts)
*   `hlt`: หยุดพัก CPU (ประหยัดพลังงาน) จนกว่าจะถูกปลุกโดย Interrupt
